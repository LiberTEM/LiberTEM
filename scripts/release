#!/usr/bin/env python
# -*- encoding: utf-8 -*-
import os
import re
import sys
import json
import glob
import shutil
import subprocess
from os.path import join

from github import Github, UnknownObjectException
from pkg_resources import parse_version
from pkg_resources.extern.packaging.version import LegacyVersion
import click

HERE = os.path.abspath(os.path.dirname(__file__))
BASE_DIR = os.path.normpath(join(HERE, '..'))

VERSION_PAT = re.compile(
    r'^(?P<full>(?P<prefix>v)?(?P<noprefix>(?P<breaking>\d+)\.(?P<feature>\d+)\.(?P<fix>\d+)'
    r'(?P<rc>rc\d+)?(?P<dev>\.dev0)?))$'
)

# matches things like v0.2.x or v1.x
STABLE_VERSION_PAT = re.compile(
    r'^v\d+\.(\d+|x)(\.(\d+|x))?$'
)


def render_version(version_file, new_version):
    version_stm = '__version__ = "{}"\n'.format(new_version)
    with open(version_file, 'wb') as f:
        f.write(version_stm.encode("utf8"))


def read_version(version_file):
    res = {}
    with open(version_file) as f:
        exec(f.read(), res)
    return res['__version__']


def get_version_fn():
    return join(BASE_DIR, 'src', 'libertem', '__version__.py')


def do_git_commit(old_version, new_version, version_file):
    cmd = ["git", "commit", version_file, "-m",
           "bump version: {} â†’ {}".format(old_version, new_version)]
    subprocess.check_call(cmd)


def do_git_tag(tag):
    cmd = ["git", "tag", tag]
    subprocess.check_call(cmd)


def validate_version_tag():
    """
    Validate the current version tag. rules:

     1) There must be exactly one version tag, and it has to conform to
        to the version pattern.
     2) The tag needs to have a prefix of "v".
    """
    tags = get_current_tags()
    matches = tag_matches(tags)
    if len(matches) != 1:
        raise click.ClickException(
            "can only have a single version tag for HEAD, aborting"
        )
    version_tag = matches[0]
    if version_tag['prefix'] != 'v':
        raise click.ClickException(
            "version tags need to have a 'v' prefix"
        )
    v = parse_version(version_tag['full'])
    if isinstance(v, LegacyVersion):
        raise click.ClickException(
            "The version tag %s could not be parsed as valid version" % v
        )

    version_from_file = parse_version(read_version(get_version_fn()))
    if isinstance(version_from_file, LegacyVersion):
        raise click.ClickException(
            "__version__ %s could not be parsed as valid version" % version_from_file
        )
    if version_from_file != v:
        raise click.ClickException(
            "version tag %s and __version__ %s do not match" % (
                v, version_from_file
            )
        )
    return True


def get_current_tags():
    """
    returns list of tags that point to HEAD
    """
    cmd = ["git", "tag", "--points-at", "HEAD"]
    return subprocess.check_output(cmd, text="utf-8").strip().split("\n")


def get_release_tag():
    """
    A commit can have more than one tag (but should only have one version tag).
    This function returns the matching version tag as a match dictionary.
    """
    tags = get_current_tags()
    matches = tag_matches(tags)
    if len(matches) == 0:
        return None
    elif len(matches) == 1:
        return matches[0]
    else:
        raise Exception(
            "cannot have more than one version tags per commit"
        )


def get_latest_tag():
    """
    return the latest tags, looking "back" from HEAD
    """
    try:
        cmd = ["git", "describe", "--abbrev=0", "--tags"]
        return subprocess.check_output(cmd, text="utf-8").strip()
    except subprocess.CalledProcessError:
        return ""


def tag_matches(tags):
    """
    """
    matches = [
        VERSION_PAT.match(tag)
        for tag in tags
    ]
    return [m.groupdict()
            for m in matches
            if m is not None]


def get_version_tag():
    """
    get the current version tag as match dict
    """
    version_tags = tag_matches(get_current_tags())
    if len(version_tags) == 1:
        return version_tags[0]


def current_version_tag_is_rc():
    return get_release_kind() == "rc"


def current_version_tag_is_release():
    return get_release_kind() == "release"


def get_release_kind():
    match = get_release_tag()
    if match is None:
        return "dev"
    if match['rc'] is not None:
        return "rc"
    elif match['rc'] is None and match['dev'] is None:
        return "release"
    else:
        return "dev"


def get_wheel():
    wheels = glob.glob("%s/dist/*.whl" % BASE_DIR)
    assert len(wheels) == 1, "expected only one wheel, have: %s" % wheels
    return wheels[0]


def get_sdist():
    sdists = glob.glob("%s/dist/*.tar.gz" % BASE_DIR)
    assert len(sdists) == 1, "expected only one tarball, have: %s" % sdists
    return sdists[0]


def get_py_release_files():
    """
    get wheel and sdist files (basically dist/*)
    """
    return glob.glob("%s/dist/*" % BASE_DIR)


def upload_to_zenodo(verbose, parent, token, sandbox_token):
    if verbose:
        print("uploading to zenodo")

    wheel = get_wheel()
    sdist = get_sdist()

    release = get_release_kind()

    if release == "dev":
        raise click.ClickException("don't want to upload to zenodo from dev release")
    elif release == "rc":
        url = "https://sandbox.zenodo.org/api/"
        os.environ['ZENODO_OAUTH_TOKEN'] = sandbox_token
    elif release == "release":
        url = "https://zenodo.org/api/"
        os.environ['ZENODO_OAUTH_TOKEN'] = token

    out = subprocess.check_output([
        "python", join(HERE, "zenodo_upload"),
        "--wheel=%s" % wheel,
        "--tarball=%s" % sdist,
        "--url=%s" % url,
        "--parent=%s" % parent,
        "--mask-zenodo-exception",
    ])

    if verbose and out:
        print(out.decode("utf-8"))


def get_release_msg():
    parts = []
    travis_url = os.environ.get("TRAVIS_BUILD_WEB_URL", "")
    if travis_url:
        parts.append("Travis CI build log: %s" % travis_url)
    return "\n\n".join(parts)


def upload_to_github(verbose, files, token, release):
    if verbose:
        print("uploading files to github:", files)
    msg = get_release_msg()

    if verbose:
        print("release message:", msg)

    g = Github(token)
    repo = g.get_repo("LiberTEM/LiberTEM")

    # FIXME: what if we are not in context of travis?
    target = os.environ["TRAVIS_COMMIT"]
    release_data = {
        "message": msg,
        "target_commitish": target,
    }
    if release == "dev":
        release_data.update({
            "tag": "continuous",
            "name": "Continuous build",
            "draft": False,
            "prerelease": True,
        })
        # first, delete existing continuous tag and release:
        try:
            cont_release = repo.get_release("continuous")
            cont_release.delete_release()
            if verbose:
                print("deleted existing continuous release")
        except UnknownObjectException:
            pass
        try:
            cont_tag = repo.get_git_ref("tags/continuous")
            cont_tag.delete()
            if verbose:
                print("deleted existing continuous tag")
        except UnknownObjectException:
            pass
        if verbose:
            print("continuous release")
    elif release == "rc":
        tag = get_release_tag()
        release_data.update({
            "tag": tag['full'],
            "name": "Release Candidate %s" % tag['full'],
            "draft": False,
            "prerelease": True,
        })
        if verbose:
            print("release candidate, tag:", tag['full'])
    elif release == "release":
        tag = get_release_tag()
        release_data.update({
            "tag": tag['full'],
            "name": "Release %s" % tag['full'],
            "draft": False,
            "prerelease": False,
        })
        if verbose:
            print("release, tag:", tag['full'])
    else:
        raise ValueError("unknown release kind: %s" % release)

    rel = repo.create_git_release(**release_data)

    for path in files:
        rel.upload_asset(path=path, content_type='application/octet-stream')


def build_appimage(verbose):
    APPIMAGE_DIR = join(BASE_DIR, 'packaging', 'appimage')

    if verbose:
        print("building AppImage in %s" % APPIMAGE_DIR)

    # cleanup existing AppDir
    APPDIR = join(APPIMAGE_DIR, 'AppDir')
    if os.path.exists(APPDIR):
        shutil.rmtree(APPDIR)

    cmd = [
        join(APPIMAGE_DIR, 'make_app_image.sh')
    ]
    output = subprocess.check_output(cmd, text="utf-8", cwd=APPIMAGE_DIR).strip()

    if verbose:
        print(output)

    # FIXME: where does the zsync file come from?
    appimage_files = glob.glob(join(APPIMAGE_DIR, 'LiberTEM*.AppImage*'))

    return appimage_files


def prepare_upload(verbose):
    """
    Prepare for upload. This includes:

     * building sdist and wheel
    """
    if verbose:
        print("preparing for upload")

    if verbose:
        print("building wheel and sdist")

    out = subprocess.check_output([
        "python", "setup.py", "sdist", "bdist_wheel"
    ], cwd=BASE_DIR)

    if verbose and out:
        print(out.decode("utf-8"))


def upload_to_pypi(verbose, user, password):
    files = get_py_release_files()
    cmd = ["twine", "upload"]
    release = get_release_kind()

    cmd.extend(["-u", user])
    cmd.extend(["-p", password])

    # upload command for test.pypi.org:
    # twine upload --repository-url https://test.pypi.org/legacy/ dist/*

    if release == "dev":
        raise Exception("won't upload dev release to pypi")
    elif release == "rc":
        cmd.extend(["--repository-url", "https://test.pypi.org/legacy/"])
    elif release == "release":
        pass
    else:
        raise Exception("unknown release kind %s" % release)

    cmd.extend(files)

    out = subprocess.check_output(cmd)

    if verbose:
        print(out)


@click.group()
@click.option('--verbose/--no-verbose', default=True)
@click.pass_context
def cli(ctx, verbose):
    ctx.obj['verbose'] = verbose


@cli.command()
@click.pass_context
def is_rc(ctx):
    res = current_version_tag_is_rc()
    if ctx.obj['verbose']:
        print("is rc?", res)
    sys.exit(int(not res))


@cli.command()
@click.option('--dry-run/--no-dry-run', default=True,
              help="don't actually upload, only prepare files etc.")
@click.option('--pypi-user', type=str, show_envvar=True)
@click.option('--pypi-password', type=str, show_envvar=True)
@click.option('--pypi-test-user', type=str, show_envvar=True)
@click.option('--pypi-test-password', type=str, show_envvar=True)
@click.option('--token', type=str, show_envvar=True,
              help='Github token for creating releases')
@click.option('--zenodo-sandbox-token', type=str, show_envvar=True,
              help='Zenodo sandbox token for RC upload testing')
@click.option('--zenodo-token', type=str, show_envvar=True,
              help='Zenodo production token for final release upload')
@click.option('--zenodo-parent', type=str, show_envvar=True,
              help='Zenodo production parent deposition id')
@click.option('--zenodo-sandbox-parent', type=str, show_envvar=True,
              help='Zenodo sandbox parent deposition id')
@click.pass_context
def upload(ctx, dry_run, pypi_user, pypi_password, pypi_test_user, pypi_test_password, token,
           zenodo_sandbox_token, zenodo_token, zenodo_parent, zenodo_sandbox_parent):
    """
    prepare, build and upload libertem to github, zenodo and pypi
    (if release candidate, to the test instance(s))
    """

    if dry_run:
        print("NOTE: running in dry-run mode, specify --no-dry-run to really upload!")

    is_rc = current_version_tag_is_rc()
    is_release = current_version_tag_is_release()

    if is_rc or is_release:
        validate_version_tag()

    if is_rc:
        # we want to upload release candidates to test.pypi.org:
        assert (pypi_test_user is not None and pypi_test_password is not None)
    if is_release:
        # releases need the "real" pypi credentials:
        assert (pypi_user is not None and pypi_password is not None)

    prepare_upload(verbose=ctx.obj['verbose'])

    # validate zenodo-upload.json:
    with open(join(BASE_DIR, 'packaging/zenodo-upload.json')) as f:
        json.load(f)

    if not dry_run:
        if is_release or is_rc:
            upload_to_zenodo(verbose=ctx.obj['verbose'],
                             parent=zenodo_sandbox_parent if is_rc else zenodo_parent,
                             token=zenodo_token, sandbox_token=zenodo_sandbox_token)
        if is_release:
            upload_to_pypi(ctx.obj['verbose'], user=pypi_user, password=pypi_password)
        elif is_rc:
            upload_to_pypi(ctx.obj['verbose'], user=pypi_test_user, password=pypi_test_password)

    release = get_release_kind()

    appimage_files = build_appimage(verbose=ctx.obj['verbose'])
    github_files = get_py_release_files()
    github_files.extend(appimage_files)

    branch = os.environ['TRAVIS_BRANCH']

    is_master = branch == "master"
    is_stable_branch = STABLE_VERSION_PAT.match(branch) is not None
    is_pull_request = os.environ['TRAVIS_PULL_REQUEST'] != "false"

    if (is_master or is_stable_branch) and not is_pull_request:
        if dry_run:
            print("would upload the following files to github:")
            for f in github_files:
                print(f)
        else:
            upload_to_github(ctx.obj['verbose'], github_files, token=token, release=release)
    else:
        print(
            "branch is not master or stable (or CI run is for PR)"
            ", not uploading to github (files=%s)" % github_files
        )


@cli.command()
@click.pass_context
def status(ctx):
    version_file = get_version_fn()
    current_version = read_version(version_file)
    print("current version: %s" % current_version)
    print("version tags for HEAD: %s" % [m['full'] for m in tag_matches(get_current_tags())])
    print("is release candidate? %s" % current_version_tag_is_rc())
    kind = get_release_kind()
    if kind in ["rc", "release"]:
        print("validating version tag...")
        validate_version_tag()
        print("done.")


@cli.command()
@click.pass_context
def do_build_appimage(ctx):
    appimage_files = build_appimage(verbose=ctx.obj['verbose'])
    print("success, files=", appimage_files)


@cli.command()
@click.argument('new_version', type=str)
@click.option('--tag/--no-tag', help='create a git tag after bumping (implies --commit)',
              default=False)
@click.option('--commit/--no-commit', help='create a git commit after bumping',
              default=False)
@click.option('--force/--no-force', help='force operation, even if it doesn\'t fit our conventions',
              default=False)
def bump(new_version, tag, commit, force):
    """
    bump the version in libertem.__version__

    NEW_VERSION should be pep440 compatible and conform to our version conventions
    """
    if tag and not commit:
        commit = True
        print("NOTE: implicitly enabling --commit")
    match = VERSION_PAT.match(new_version)
    if match is None:
        raise click.UsageError("could not parse version, may not conform to our scheme")
    new_version = match['noprefix']

    if tag and match.groupdict()['dev'] is not None:
        if not force:
            raise click.ClickException("dev releases should not be tagged, use --force to override")
        else:
            print("NOTE: tagging a dev release because of --force")

    version_file = get_version_fn()
    old_version = read_version(version_file)
    render_version(version_file, new_version)
    version_tag = "v{}".format(new_version)

    if commit:
        do_git_commit(old_version=old_version, new_version=new_version,
                      version_file=version_file)
    if tag:
        do_git_tag(tag=version_tag)
    print("version bumped from {} to {}".format(old_version, new_version))

    if tag:
        print("now, push the new version: $ git push && git push origin {}".format(version_tag))
    else:
        if commit:
            print("now, tag as needed and push")
        else:
            print("now, commit the new version, tag as needed and push")


if __name__ == "__main__":
    cli(obj={}, auto_envvar_prefix="LT_RELEASE")
